# 实现Sudoku类

本实验目标为实现一个Sudoku类，根据字符串获取数独表中个单元格的候选值。

### 业务功能

Input：017903600000080000900000507072010430000402070064370250701000065000030000005601720 

更多测例，可从 https://www.sudokuwiki.org/ 获取

解析字符串输入，得到Sudoku实例

推理棋盘，得到各单元格候选值

场景下其它合理功能

### 代码质量

OO基础技术：实现的Sudoku类应当符合所用语言OOP的技术惯例，包括必要的基础技术方法，包括并不限于：对象创建、初始化、克隆、串行化、外表化、比较（序）

正确性：必要的测试代码和测试用例

可理解性：恰当的命名、合理的模块（函数）划分、必要的注释

## 设计

本实验设计了两个主要类：Sudoku 和 Grid。

Grid 类是一个通用的二维矩阵类，旨在保存和管理二维矩阵数据。该类提供了多种功能，包括初始化矩阵、拷贝和克隆矩阵的能力，以及串行化和反串行化功能，使得矩阵的数据可以方便地保存和恢复。此外，Grid 类还支持获取特定行和列的数据，查找指定单元格所在的 3x3 子块，确保在数独游戏等应用中高效处理矩阵操作。

Sudoku 类则是本实验的核心方法类，专门用于解析数独表格。它通过接受一个字符串输入，将其解析为 9x9 的数独矩阵，确保输入字符串格式有效。在解析完成后，Sudoku 类能够获取每个空白单元格的候选值，帮助用户理解每个空格可以填入的可能数字。此外，该类提供了结果展示功能，以直观的方式呈现数独表格的状态和候选值，并实现了错误处理机制，以便在解析输入时捕捉并反馈任何潜在的问题。

## 实现

本实验分别使用静态语言C++和动态语言python实现了Sudoku类。

### 初始化

```
/*构造函数，根据行列数生成二维矩阵*/
Grid(int row, int col)
{
    matrix.resize(row, std::vector<int>(col, 0));
};

/*构造函数，根据二维矩阵生成Grid对象*/
Grid(const std::vector<std::vector<int>>& initMatrix)
{
    matrix = initMatrix;
}

/*拷贝构造函数*/
Grid(const Grid& initGrid)
{
    matrix = initGrid.matrix;
}

/*析构函数*/
~Grid(){};
```
提供三种初始化方法，分别为根据行列数生成二维矩阵，根据二维数组生成二维矩阵，根据相同的Grid对象进行拷贝构造。

### 串行化与反串行化

```
/*串行化*/
std::string serialize() const {
    std::ostringstream oss;
    oss << rows() << " " << cols() << "\n"; // 首先写入行列信息
    for (const auto& row : matrix) {
        for (int val : row) {
            oss << val << " ";
        }
        oss << "\n"; // 每行结束后换行
    }
    return oss.str();
}

/*反串行化*/
void deserialize(const std::string& str) {
    std::istringstream iss(str);
    int r, c;
    iss >> r >> c; // 读取行列信息
    matrix.resize(r, std::vector<int>(c, 0));

    for (int i = 0; i < r; ++i) {
        for (int j = 0; j < c; ++j) {
            iss >> matrix[i][j]; // 逐个读取矩阵元素
        }
    }
}
```
实现对于二维矩阵内部数据的串行化与反串行化。

### 错误检测

```
Sudoku(std::string input): cells(9, 9)
{
    if(input.size() != 81){
        throw "The string length is invalid!";
    }
    for(int i=0;i<81;++i)
    {
        char ch = input[i];
        if(ch < '0' || ch > '9'){
            throw "The char is invalid!";
        }
        cells.CellChange(i/9, i%9, ch-'0');
    }
}
```
在初始化Sudoku类时进行字符串解析，并提供简单的错误检测。

## 测试

本实验提供了简单的测试代码及测试案例：
```
int main(int argc, char const *argv[])
{
    /*测试代码*/
    std::string input = "017903600000080000900000507072010430000402070064370250701000065000030000005601720";
    /*
    字符串长度不足81位报错测试：79036000000800009000005070720104300004020700643702
    字符串包含异常字符报错测试：01790360000008000090000050707201043000040207006437025070100006500003000000560172a
    其余正常测试案例：005060900000500000000807050090043078001000400840700080060204000000008000003010700
    */

    try
    {
        Sudoku answer(input);
        answer.Solution();
    }
    catch(const char *err)
    {
        std::cerr << err << '\n';
    }
    
    return 0;
}
```

实验结果：
```
The original Sudoku table is displayed!
| 0 | 0 | 5 | 0 | 6 | 0 | 9 | 0 | 0 |
| 0 | 0 | 0 | 5 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 8 | 0 | 7 | 0 | 5 | 0 |
| 0 | 9 | 0 | 0 | 4 | 3 | 0 | 7 | 8 |
| 0 | 0 | 1 | 0 | 0 | 0 | 4 | 0 | 0 |
| 8 | 4 | 0 | 7 | 0 | 0 | 0 | 8 | 0 |
| 0 | 6 | 0 | 2 | 0 | 4 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 8 | 0 | 0 | 0 |
| 0 | 0 | 3 | 0 | 1 | 0 | 7 | 0 | 0 |
The matrix is indexed from 1 to 81 from left to right and top to bottom!
Below are the candidate values for the spaces:
(1, 1) : 1 2 3 4 7
(1, 2) : 1 2 3 7 8
(1, 4) : 1 3 4
(1, 6) : 1 2
(1, 8) : 1 2 3 4
(1, 9) : 1 2 3 4 7
(2, 1) : 1 2 3 4 6 7 9
(2, 2) : 1 2 3 7 8
(2, 3) : 2 4 6 7 8 9
(2, 5) : 2 3 9
(2, 6) : 1 2 9
(2, 7) : 1 2 3 6 8
(2, 8) : 1 2 3 4 6
(2, 9) : 1 2 3 4 6 7
(3, 1) : 1 2 3 4 6 9
(3, 2) : 1 2 3
(3, 3) : 2 4 6 9
(3, 5) : 2 3 9
(3, 7) : 1 2 3 6
(3, 9) : 1 2 3 4 6
(4, 1) : 2 5 6
(4, 3) : 2 6
(4, 4) : 1 6
(4, 7) : 1 2 5 6
(5, 1) : 2 3 5 6 7
(5, 2) : 2 3 5 7
(5, 4) : 6 9
(5, 5) : 2 5 8 9
(5, 6) : 2 5 6 9
(5, 8) : 2 3 6 9
(5, 9) : 2 3 5 6 9
(6, 3) : 2 6
(6, 5) : 2 5 9
(6, 6) : 1 2 5 6 9
(6, 7) : 1 2 3 5 6
(6, 9) : 1 2 3 5 6 9
(7, 1) : 1 5 7 9
(7, 3) : 7 8 9
(7, 5) : 3 5 7 9
(7, 7) : 1 3 5 8
(7, 8) : 1 3 9
(7, 9) : 1 3 5 9
(8, 1) : 1 2 4 5 7 9
(8, 2) : 1 2 5 7
(8, 3) : 2 4 7 9
(8, 4) : 3 6 9
(8, 5) : 3 5 7 9
(8, 7) : 1 2 3 5 6
(8, 8) : 1 2 3 4 6 9
(8, 9) : 1 2 3 4 5 6 9
(9, 1) : 2 4 5 9
(9, 2) : 2 5 8
(9, 4) : 6 9
(9, 6) : 5 6 9
(9, 8) : 2 4 6 9
(9, 9) : 2 4 5 6 9
```

本实验成功完成了实验目标，并实现了简单的错误检测。